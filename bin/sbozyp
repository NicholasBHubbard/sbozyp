#!/usr/bin/perl

use strict;
use warnings FATAL => 'all';
use v5.34.0; # The Perl version on Slackware 15.0 (sbozyp's min version)

package Sbozyp;

our $VERSION = '1.0.0';

use File::Basename;
use File::Temp;
use File::stat;
use File::Copy qw(mv);
use File::Path qw(make_path remove_tree);
use Getopt::Long qw(GetOptionsFromArray :config no_ignore_case bundling);

$SIG{INT} = sub { die "sbozyp: got a SIGINT ... going down!\n" };

our %CONFIG = (
    # defaults
    TMPDIR => '/tmp/sbozyp',
    CLEANUP => 1,
    REPO_ROOT => '/var/lib/sbozyp/SBo',
    REPO_GIT_URL => 'git://git.slackbuilds.org/slackbuilds.git',
    REPO_GIT_BRANCH => '15.0'
);

main(@ARGV) unless caller;

sub main { # NOT TESTED
    my @argv = @_;
    my $cmd = shift(@argv) or die_usage();
    parse_config_file(); # mutates the global %CONFIG
    # provide command abbreviations
    if    ($cmd eq 'in') { $cmd = 'install' }
    elsif ($cmd eq 'qr') { $cmd = 'query'   }
    elsif ($cmd eq 'rm') { $cmd = 'remove'  }
    elsif ($cmd eq 'se') { $cmd = 'search'  }
    elsif ($cmd eq 'sy') { $cmd = 'sync'    }
    elsif ($cmd eq 'up') { $cmd = 'upgrade' }
    # run the command
    if    ($cmd =~ /^(?:--help|-h)$/)    { print help_string()  }
    elsif ($cmd =~ /^(?:--version|-v)$/) { print $VERSION, "\n" }
    elsif ($cmd eq 'install')            { install_main(@argv)  }
    elsif ($cmd eq 'query')              { query_main(@argv)    }
    elsif ($cmd eq 'remove')             { remove_main(@argv)   }
    elsif ($cmd eq 'search')             { search_main(@argv)   }
    elsif ($cmd eq 'upgrade')            { upgrade_main(@argv)  }
    elsif ($cmd eq 'sync')               { sync_main(@argv)     }
    else                                 { die_usage()          }
    # all good
    exit 0;
}

            ####################################################
            #                     COMMANDS                     #
            ####################################################

sub install_main { # NOT TESTED
    my $usage = 'usage: sbozyp install [-hnsi] <pkgname>';
    my $help_msg = <<"END_HELP";
$usage

options are:
  -h    print this help message
  -n    do not install package dependencies
  -s    sync repository before installation
  -i    non-interactive (DANGEROUS)
END_HELP
    sbozyp_getopts(
        \@_,
        'h' => \my $help,
        'n' => \my $no_deps,
        's' => \my $sync,
        'i' => \my $non_interactive
    );
    if ($help) { print $help_msg ; return }
    i_am_root_or_die();
    my $pkg = pkg($_[0] // die "$usage\n");
    sync_repo() if $sync;
    my @queue = $no_deps ? ($pkg) : pkg_queue($pkg);
    unless ($non_interactive) {
        for my $pkg (@queue) {
            if ($pkg->{HAS_EXTRA_DEPS}) {
                print "sbozyp: pkg '@{[$pkg->{PKGNAME}]}' has optional dependencies\n";
              PROMPT_USER:
                print '  would you like to view ', $pkg->{PKGNAME}, '\'s README file? y/n', "\n";
                print '  -> ';
                chomp(my $decision = <STDIN>);
                if ($decision eq 'y') { sbozyp_system($ENV{PAGER} // 'less', $pkg->{README_FILE}) }
                elsif ($decision eq 'n') { ; }  # do nothing
                else  { print "  '$decision' is not a valid option\n" ; goto PROMPT_USER }
            }
        }
        print 'sbozyp: pkgs to install:', "\n";
        print '  ', $_->{PKGNAME}, "\n" for @queue;
      PROMPT_USER:
        print '  do you want to proceed? y/n', "\n";
        print '  -> ';
        chomp(my $decision = <STDIN>);
        if    ($decision eq 'y') { ; } # do nothing
        elsif ($decision eq 'n') { exit 0 }
        else  { print "  '$decision' is not a valid option\n" ; goto PROMPT_USER }
    }
    for my $pkg (@queue) {
        my $slackware_pkg = build_slackware_pkg($pkg);
        install_slackware_pkg($slackware_pkg);
    }
}

sub remove_main { # NOT TESTED
    i_am_root_or_die();
    'TODO';
}

sub search_main { # NOT TESTED
    my $usage = 'usage: sbozyp search [-hcn] <regex>';
    my $help_msg = <<"END_HELP";
$usage

options are:
  -h    print this help message
  -c    match case sensitive
  -n    match against CATEGORY/PKGNAM insteed of just PKGNAM
END_HELP
    sbozyp_getopts(
        \@_,
        'h' => \my $help,
        'c' => \my $case_sensitive,
        'n' => \my $match_category
    );
    if ($help) { print $help_msg ; return }
    my $regex_arg = $_[0] // die "$usage\n";
    my $regex = $case_sensitive ? qr/$regex_arg/ : qr/$regex_arg/i;
    my @matches = map { $_ = pkg($_) } grep {
        $match_category ? $_ =~ $regex : basename($_) =~ $regex;
    } all_pkgnames();
    if (@matches) {
        print "sbozyp: the following packages match the regex '$regex_arg'\n";
        print '  ', $_->{PKGNAME}, "\n" for @matches;
    } else {
        sbozyp_die("no packages match the regex '$regex_arg'");
    }
}

sub query_main { # NOT TESTED
    my $usage = 'usage: sbozyp query [-h] <pkgname>';
    my $help_msg = <<"END_HELP";
$usage

Query package named 'pkgname'.

This command will drop you into an interactive prompt for viewing 'pkgname's
files in your pager.

options are:
  -h    print this help message
END_HELP
    sbozyp_getopts(\@_, 'h' => \my $help);
    if ($help) { print $help_msg ; return }
    my $pkg = pkg($_[0] // die "$usage\n");
    query_pkg($pkg);
}

sub sync_main { # NOT TESTED
    i_am_root_or_die();
    my $usage = 'usage: sbozyp sync <TODO>';
    sync_repo();
}

            ####################################################
            #                    SUBROUTINES                   #
            ####################################################

sub pkg {
    my ($prgnam, $ignore_cache) = @_;
    my $pkgname = find_pkgname($prgnam) // sbozyp_die("could not find a package named '$prgnam'");
    my $info_file = "$CONFIG{REPO_ROOT}/$pkgname/@{[basename($pkgname)]}.info";
    my %info = parse_info_file($info_file);
    my $pkg = {
        PKGNAME         => $pkgname,
        PKGDIR          => "$CONFIG{REPO_ROOT}/$pkgname",
        INFO_FILE       => $info_file,
        SLACKBUILD_FILE => "$CONFIG{REPO_ROOT}/$pkgname/".basename($pkgname).'.SlackBuild',
        DESC_FILE       => "$CONFIG{REPO_ROOT}/$pkgname/slack-desc",
        README_FILE     => "$CONFIG{REPO_ROOT}/$pkgname/README",
        PRGNAM          => $info{PRGNAM},
        VERSION         => $info{VERSION},
        HOMEPAGE        => $info{HOMEPAGE},
        MAINTAINER      => $info{MAINTAINER},
        EMAIL           => $info{EMAIL},
        DOWNLOAD        => [split ' ', $info{DOWNLOAD}],
        MD5SUM          => [split ' ', $info{MD5SUM}],
        DOWNLOAD_x86_64 => [split ' ', $info{DOWNLOAD_x86_64}],
        MD5SUM_x86_64   => [split ' ', $info{MD5SUM_x86_64}],
        REQUIRES        => [grep { $_ ne '%README%' } split(' ', $info{REQUIRES})],
        HAS_EXTRA_DEPS  => scalar(grep { $_ eq '%README%' } split(' ', $info{REQUIRES})),
        ARCH_UNSUPPORTED  => do {
            my @urls = split ' ', arch() eq 'x86_64' ? $info{DOWNLOAD_x86_64} : $info{DOWNLOAD};
            if    (grep { $_ eq 'UNSUPPORTED' } @urls) { 'unsupported' }
            elsif (grep { $_ eq 'UNTESTED'    } @urls) { 'untested'    }
            else                                       { 0             }
        }
    };
    return wantarray ? %$pkg : $pkg;
}

sub query_pkg { # TODO: test query_pkg()
    my ($pkg) = @_;
    my $pkgdir = $pkg->{PKGDIR};
    my @pkg_files = sbozyp_find_files_recursive($pkgdir);
    my $score = sub {
        my ($file) = @_;
        my $bn = basename($file);
        $bn =~ /^README$/      and return 0;
        $bn =~ /\.info$/       and return 1;
        $bn =~ /\.SlackBuild$/ and return 2;
        $bn =~ /^doinst\.sh/   and return 3;
        $bn =~ /^slack-desc$/  and return 4;
        return 5;
    };
    @pkg_files = sort { $score->($a) <=> $score->($b) } @pkg_files;
    while (1) {
        print 'sbozyp: query ', $pkg->{PKGNAME}, ': select a file to view in your pager (q to quit):', "\n";
        for (my $i = 0; $i < @pkg_files; $i++) {
            printf "  %2d  %s\n", $i+1, $pkg_files[$i] =~ s/^$pkgdir\///r;
        }
        print '  -> ';
        chomp(my $decision = <STDIN>);
        if ($decision =~ /^(?:q|quit)$/) {
            last;
        } elsif ($decision =~ /^\d+$/ and $decision > 0 and my $file = $pkg_files[$decision-1]) {
            sbozyp_system($ENV{PAGER} // 'less', $file);
        } else {
            print "  '$decision' is not a valid option\n";
        }
    }
}

sub all_categories {
    my @categories = sort map {
        basename($_);
    } sbozyp_qx("find '$CONFIG{REPO_ROOT}' -not -path '*/.git' -type d -mindepth 1 -maxdepth 1");
    return @categories
}

sub all_pkgnames {
    my @pkgnames = sort map {
        my ($pkgname) = $_ =~ m,/([^/]+/[^/]+)$,;
    } sbozyp_qx("find '$CONFIG{REPO_ROOT}' -not -path '*/.git/*' -type d -mindepth 2 -maxdepth 2");
    return @pkgnames;
}

sub find_pkgname {
    my ($prgnam) = @_;
    $prgnam or return;
    return $prgnam if $prgnam =~ m,^[^/]+/[^/]+$, && -d "$CONFIG{REPO_ROOT}/$prgnam";
    my $pkgname;
    for my $category (all_categories()) {
        $pkgname = "$category/$prgnam" if -d "$CONFIG{REPO_ROOT}/$category/$prgnam";
    }
    return $pkgname;
}

sub parse_info_file {
    my ($info_file) = @_;
    my $fh = sbozyp_open('<', $info_file);
    my $info_file_content = do { local $/; <$fh> }; # slurp the info file
    my %info = $info_file_content =~ /^(\w+)="([^"]*)"/mg;
    # Multiline values are broken up with newline escapes. Lets squish them into single spaces.
    $info{$_} =~ s/\\\n\s+//g for keys %info;
    return %info;
}

sub is_multilib_system {
    my $is_multilib_system = -f '/etc/profile.d/32dev.sh';
    return $is_multilib_system;
}

sub arch {
    my $arch = sbozyp_qx('uname -m');
    return $arch;
}

sub sbozyp_getopts {
    my $error;
    local $SIG{__WARN__} = sub { chomp($error = $_[0]) };
    GetOptionsFromArray(@_) or sbozyp_die($error);
}

sub sbozyp_die {
    my ($msg) = @_;
    die "sbozyp: error: $msg\n";
}

sub sbozyp_system {
    my @cmd = @_;
    my $exit_status = system(@cmd) >> 8;
    unless (0 == $exit_status) {
        sbozyp_die("system command '@cmd' exited with status $exit_status");
    }
}

sub sbozyp_qx {
    my ($cmd) = @_;
    wantarray ? chomp(my @output = qx($cmd)) : chomp(my $output = qx($cmd));
    unless (0 == $?) {
        my $exit_status = $? >> 8;
        sbozyp_die("system command '$cmd' exited with status $exit_status");
    }
    return wantarray ? @output : $output;
}

sub sbozyp_tee {
    my ($cmd) = @_;
    my $tmp = File::Temp->new(DIR => $CONFIG{TMPDIR}, TEMPLATE => 'sbozyp_XXXXXX');
    $cmd = "set -o pipefail && ( $cmd ) | tee '$tmp'";
    sbozyp_system('bash', '-c', $cmd);
    seek $tmp, 0, 0;
    my $stdout = do { local $/; <$tmp> };
    return $stdout;
}

sub sbozyp_open {
    my ($mode, $path) = @_;
    open(my $fh, $mode, $path) or sbozyp_die("could not open file '$path': $!");
    return $fh;
}

sub sbozyp_unlink {
    my ($file) = @_;
    unlink $file or sbozyp_die("could not unlink file '$file': $!");
}

sub sbozyp_copy {
    my ($file, $dest) = @_;
    sbozyp_system('cp', '-a', -d $file ? "$file/." : $file, $dest);
}

sub sbozyp_move {
    my ($file, $dest) = @_;
    mv($file, $dest) or sbozyp_die("could not move '$file' to '$dest': $!");
}

sub sbozyp_readdir {
    my ($dir) = @_;
    opendir(my $dh, $dir) or sbozyp_die("could not opendir '$dir': $!");
    my @files = sort map { "$dir/$_" } grep { !/^\.\.?$/ } readdir($dh);
    return @files;
}

sub sbozyp_find_files_recursive {
    my ($dir) = @_;
    my @files;
    my $find_files_recursive = sub {
        for my $f (@_) {
            if (-f $f) {
                push @files, $f;
            } else {
                __SUB__->(sbozyp_readdir($f));
            }
        }
    };
    $find_files_recursive->(sbozyp_readdir($dir));
    return sort(@files);
}

sub sbozyp_chdir {
    my ($dir) = @_;
    chdir $dir or sbozyp_die("could not chdir to '$dir': $!");
}

sub sbozyp_mkdir {
    my ($dir) = @_;
    unless (-d $dir) {
        make_path($dir, {error => \my $err});
        if ($err) {
            for my $diag (@$err) {
                my (undef, $err_msg) = %$diag;
                sbozyp_die("could not mkdir '$dir': $err_msg");
            }
        }
    }
    return $dir;
}

sub sbozyp_mkdir_empty {
    my ($dir) = @_;
    if (-d $dir) {
        remove_tree($dir, {error => \my $err});
        if ($err) {
            for my $diag (@$err) {
                my (undef, $err_msg) = %$diag;
                sbozyp_die("could not recursively delete directory '$dir': $err_msg");
            }
        }
    }
    return sbozyp_mkdir($dir);
}

sub i_am_root_or_die {
    sbozyp_die('must be root') unless 0 == $>;
}

sub parse_config_file {
    # $config_file should only be parameterized in test code
    my $config_file = $_[0] // '/etc/sbozyp.conf';
    my $fh = sbozyp_open('<', $config_file);
    while (<$fh>) {
        chomp;
        my $line_copy = $_; # save $_ so we can create a nice error message if things go wrong
        s/#.*//;            # no comments
        s/^\s+//;           # no leading whitespace
        s/\s+$//;           # no trailing whitespace
        s/\/+$//;           # no trailing /'s
        next unless length; # is there anything left?
        my ($k, $v) = split /\s*=\s*/, $_, 2;
        $k !~ /^\s*$/ && $v !~ /^\s*$/ or sbozyp_die("could not parse line $. '$line_copy': '$config_file'");
        exists $CONFIG{$k} or sbozyp_die("invalid setting on line $. '$k': '$config_file'");
        $CONFIG{$k} = $v;
    }
}

sub sync_repo {
    sbozyp_mkdir_empty($CONFIG{REPO_ROOT});
    sbozyp_system('git', 'clone', '-b', $CONFIG{REPO_GIT_BRANCH}, $CONFIG{REPO_GIT_URL}, $CONFIG{REPO_ROOT});
}

sub pkg_queue {
    my ($pkg) = @_;
    my @queue = ($pkg);
    my $resolve_deps = sub {
        my ($pkg) = @_;
        # $pkg->{REQUIRES} will never contain %README% as its removed when we parse a pkgs info file (see pkg()).
        for my $req (@{$pkg->{REQUIRES}}) {
            my $req_pkg = pkg($req);
            @queue = grep { $req_pkg->{PKGNAME} ne $_->{PKGNAME} } @queue;
            unshift @queue, $req_pkg;
            __SUB__->($req_pkg);
        }
    };
    $resolve_deps->($pkg);
    return @queue;
}

sub merge_pkg_queues {
    my @queue;
    my %seen;
    for my $pkg (@_) {
        next if $seen{$pkg->{PKGNAME}};
        $seen{$pkg->{PKGNAME}} = 1;
        push @queue, $pkg;
    }
    return @queue;
}

sub parse_slackware_pkgname {
    my ($slackware_pkgname) = @_;
    my ($prgnam, $version) = $slackware_pkgname =~ /^([\w-]+)-([^-]*)-[^-]*-\d+_SBo$/;
    my $pkgname = find_pkgname($prgnam);
    return ($pkgname => $version);
}

sub installed_sbo_pkgs {
    my $root = $ENV{ROOT} // '/';
    my %installed_sbo_pkgs = map {
        my ($pkgname, $version) = parse_slackware_pkgname(basename($_));
    } grep /_SBo$/, sbozyp_readdir("$root/var/lib/pkgtools/packages");
    return %installed_sbo_pkgs;
}

sub prepare_pkg {
    my ($pkg) = @_;
    my $arch = arch();
    if (my $arch_problem = $pkg->{ARCH_UNSUPPORTED}) {
        sbozyp_die("'@{[$pkg->{PKGNAME}]}' is $arch_problem on $arch")
    }
    my %url_md5;
    if ($arch eq 'x86_64' and my @urls = @{$pkg->{DOWNLOAD_x86_64}}) {
        @url_md5{@urls} = @{$pkg->{MD5SUM_x86_64}};
    } else {
        my @urls = @{$pkg->{DOWNLOAD}};
        @url_md5{@urls} = @{$pkg->{MD5SUM}};
    }
    my $staging_dir = File::Temp->newdir(DIR => $CONFIG{TMPDIR}, TEMPLATE => 'sbozyp_XXXXXX');
    sbozyp_copy($pkg->{PKGDIR}, $staging_dir);
    for my $url (sort keys %url_md5) {
        my $md5 = $url_md5{$url};
        sbozyp_system('wget', '-t', 3, '-P', $staging_dir, $url);
        my $file = basename($url);
        my $got_md5 = sbozyp_qx("md5sum '$staging_dir/$file' | cut -d' ' -f1");
        if ($md5 ne $got_md5) {
            sbozyp_die("md5sum mismatch for '$url': expected '$md5': got '$got_md5'");
        }
    }
    return $staging_dir;
}

sub build_slackware_pkg {
    my ($pkg) = @_;
    local $ENV{OUTPUT} = $CONFIG{TMPDIR};
    my $staging_dir = prepare_pkg($pkg);
    my $slackbuild = $pkg->{PRGNAM} . '.SlackBuild';
    my $slackbuild_stdout = sbozyp_tee("cd '$staging_dir' && chmod +x ./$slackbuild && ./$slackbuild");
    my ($slackware_pkg) = $slackbuild_stdout =~ /Slackware package (.+) created/;
    return $slackware_pkg;
}

sub install_slackware_pkg {
    my ($slackware_pkg) = @_;
    sbozyp_system("upgradepkg --reinstall --install-new '$slackware_pkg'");
    sbozyp_unlink($slackware_pkg) if $CONFIG{CLEANUP};
}

sub remove_slackware_pkg {
    my ($slackware_pkg) = @_;
    sbozyp_system("removepkg '$slackware_pkg'");
}

1;

__END__

=pod

=head1 Name

sbozyp - A package manager for Slackware's SlackBuilds.org

=head1 TODO: write the manual

=head1 Copyright

Copyright (c) 2023 by Nicholas Hubbard (nicholashubbard@posteo.net)

=head1 License

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
sbozyp. If not, see http://www.gnu.org/licenses/.

=cut
